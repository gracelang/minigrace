import "errormessages" as errormessagesimport "ast" as astclass graceInterfaceType {    inherit graceAbstractType    // I describe a Grace interface type    // instance variables    // knownSuperTypes -- a set containing types to which it is known that I conform    // (because this has been calculated previosuly)    // methodDict -- a dictionary containing my method names as keys, and their signatures as values.    // typeName -- the name of this interface type, if it has been given a name in a type declaration.    // Otherwise, it will be known as an anonymous interface type.    var knownSuperTypes := set.empty    var methodDict := dictionary.empty    var typeName is public := "anonymous interface"            method allSignaturesConformTo (anotherType) underAssumptions (assumptions) {        return anotherType.methodNames.allSatisfy { each →            methodNamed (each).signatureConformsTo (anotherType.methodNamed (each)) inType (self) underAssumptions (assumptions)        }    }    method conformsTo (aGraceObjectType) {        return conformsTo (aGraceObjectType) underAssumptions (graceMultiDictionary.new)    }    method methodNamed (aName) {        return methodDict.at (aName) ifAbsent {            errormessages.error "this type has no method {aName}"        }    }    method conformsTo (anotherObjectType) inType (selfType) underAssumptions (assumptionsDictionary) {        if (anotherObjectType.isUnknown) then {            return true        }        if ((anotherObjectType.typeValue == self )) then {            return true        }        def other = if (anotherObjectType.isSelfType) then {            selfType        } else {            anotherObjectType        }        if (other.isVariant) then {            return other.variants.anySatisfy { each →                conformsTo (each) inType (selfType) underAssumptions (assumptionsDictionary)            }        }        if (assumptionsDictionary.at (self) includes (other)) then {            return true        }        if (methodNames.includesAll (other.methodNames).not) then {            return false        }        assumptionsDictionary.at (self) add (other)        return allSignaturesConformTo (other) underAssumptions (assumptionsDictionary)    }    method methodNamesAndSignaturesDo (a2ArgBlock) {        methodDict.keysAndValuesDo (a2ArgBlock)    }    method from (aTypeNode) {        typeName := aTypeNode.typeName        aTypeNode.methods.do { each →            def sig = graceSignature.fromParseTreeNode (each)            methodDict.at (sig.methodName) put (sig)        }    }    method methodNamed (aName) ifAbsent (aBlock) {        return methodDict.at (aName) ifAbsent (aBlock)    }    method methodNames {        return methodDict.keys    }    method asString {        "objectType " ++ typeName    }    method signatureConformsTo (aGraceObjectType) underAssumptions (aCollection) {        ...    }    method methods {        return methodDict.values    }    method conformsTo (anotherObjectType) underAssumptions (assumptionsDictionary) {        if (anotherObjectType.isUnknown) then {            return true        }        if ((anotherObjectType == self )) then {            return true        }        if (assumptionsDictionary.at (self) includes (anotherObjectType)) then {            return true        }        if (methodNames.includesAll (anotherObjectType.methodNames).not) then {            return false        }        assumptionsDictionary.at (self) add (anotherObjectType)        return allSignaturesConformTo (anotherObjectType) underAssumptions (assumptionsDictionary)    }}class graceOperatorTypeFrom (aTypeExpression) {    inherit graceAbstractType    // I represent a type operator expression, such as A & B & C or W + X + Y.      // I have two or more operands, but only one operator, because type expressions     // like A & B | C are illegal, and must be parenthesized.        var operands is public := list.with (buildTypeFrom (aTypeExpression.term))    aTypeExpression.args.do { each →        operands.addLast (buildTypeFrom (each))    }    def undefined = singleton "undefined"    var typeNameCache := undefined        method typeName {        if (undefined == typeNameCache) then {            var s := ""            operands.do { each →                s := s ++ each.typeName            } separatedBy {                s := s ++  " " ++ operatorSymbol ++ " "            }            typeNameCache := s        }        typeNameCache    }    method methodDictionary is abstract        method variants {        // answers a collection of my variants.  Unless I'm a variant type, there is just one - myself        return self    }    method typeName (aName) {        typeNameCache := aName    }    method methodNames {        return methodDictionary.keys    }    method operatorSymbol is abstract        method setOperands (aUniqueCollection) {        operands := aUniqueCollection    }    method convertToDNF is abstract}class signatureOfMethod (aMethod) {    inherit graceAbstractType    // I describe a single method in a type.    // instance variables    // methodName -- the canonical name of this method, such as "indexOf(_)ifAbsent(_)"    // parameters -- a sequence of types describing all of my parameters.    // result -- a single type describing my result    // typeParameters -- a sequence of the names of my type parameters, if any.        var parameters is public := aMethod.parameters.collect { each →        each.declaredType    }    var result := graceBuildType.from (aMethod.definingParseNode.returns)    var methodName := aMethod.name    var typeParameters is public := aMethod.definingParseNode.typeParameters.ifNil {        [ ]    } ifNotNil { tp →        tp.parameters    }        method signatureConformsTo (anotherSignature) inType (selfType) underAssumptions (assumptions) {        parameters.with (anotherSignature.parameters) do { pSelf, pOther →            if (pOther.conformsTo (pSelf) inType (selfType) underAssumptions (assumptions).not) then {                return false            }        }        return result.conformsTo (anotherSignature.result) inType (selfType) underAssumptions (assumptions)    }    method result {        return result    }    method substitute (bindings) {        def newSig = copy        newSig.parameters (parameters.collect { each →            each.substitute (bindings)        })        newSig.result (result.substitute (bindings))        return newSig    }    method parameters (anObject) {        parameters := anObject    }    method initializeFromNode (aNode) {        methodName := aNode.declaredName        parameters := aNode.parameters.collect { each →            each.declaredType        }        typeParameters := aNode.typeParameters.ifNil {            [ ]        } ifNotNil { tp →            tp.parameters        }        result := aNode.returnType        assert (result.isNotNil)    }    method methodName {        return methodName    }    method printOn (s) {        (s << "signature " << methodName )        if (hasParameters) then {            (s << "⟦")            parameters.do { each →                (s << each.name)            } separatedBy {                (s << ", ")            }            (s << "⟧")        }    }    method result (anObject) {        result := anObject    }    method signatureConformsTo (anotherSignature) underAssumptions (assumptions) {        parameters.with (anotherSignature.parameters) do { pSelf, pOther →            if (pOther.conformsTo (pSelf) underAssumptions (assumptions).not) then {                return false            }        }        return result.conformsTo (anotherSignature.result) underAssumptions (assumptions)    }}class graceSelfType {    inherit graceInterfaceType    // I represent Self, the type in which I appear.    method typeName {        return "Self"    }    method conformsTo (anotherType) inType (selfType) underAssumptions (assumptions) {    }    method isSelfType {        return true    }}class graceUnknownType {    inherit graceInterfaceType    // I have a unique instance that represents the special type annotation `Unknown`.    method isUnknown {        return true    }    method typeName {        return "Unknown"    }    method conformsTo (anotherObjectType) inType (selfType) underAssumptions (assumptionsDictionary) {        return true    }    method parent (aNode) {        // do nothing        return aNode    }    method substitute (bindings) {        return self    }    method parent {        return nil    }    method printOn (s) {        (s << "type Unknown")    }    method conformsTo (anotherObjectType) underAssumptions (assumptionsDictionary) {        return true    }}class graceAmpersandTypeFrom (typeExpr) {    inherit graceOperatorTypeFrom (typeExpr)    // I represent an operator expression containing the & operator, representing the join of types.    method conformsTo (aType) inType (selfType) underAssumptions (assumptions) {        operands.allSatisfy { each →            each.conformsTo (aType) inType (selfType) underAssumptions (assumptions)        }    }    once method methodDictionary {        // my method dictionary contains the union (join) of the methods of my arguments        def tempDict = graceMultiDictionary.empty        operands.do { each →            each.methodNamesAndSignaturesDo { k, v →                tempDict.at (k) add (v)            }        }        def result = dictionary.empty        tempDict.keysAndValuesDo { k, vs →            result.at (k) put (joinOf (vs))        }        result    }    method operatorSymbol {        return "&"    }    method joinOf (aSetOfSignatures) {        if (aSetOfSignatures.size == 1) then {            return aSetOfSignatures.anyOne        }        def sigs = aSetOfSignatures.asOrderedCollection        def firstSig = sigs.removeFirst        halt "finish implementing joinOf:"    }    method convertToDNF {        // if I represent ( t | u ) & (w), then we need to push the variant to the top level, and create        // (t & w) | (u & w)        def variantExpression = operands.detect { each →            each.isVariant        } ifNone {            return self        }        def newVariants = variantExpression.variants.collect { each →            graceAmpersandType.first (each) rest (operands.copyWithout (variantExpression)).convertToDNF        }        graceVariantType.withOperands (newVariants)    }}class gracePlusTypeFrom (typeExpr) {    inherit graceOperatorTypeFrom (typeExpr)     // I represent an operator expression containing the + operator, representing the meet of types.    once method methodDictionary {        // my method dictionary contains only those methods that are common to all of my arguments        def tempDict = graceMultiDictionary.empty        operands.do { each →            each.keysAndValuesDo { k, v →                tempDict.at (k) add (v)            }        }        def n = operands.size        def result = dictionary.empty        tempDict.keysAndValuesDo { k, vs →            if (vs.size == n) then {                result.at (k) put (meetOf (vs))            }        }        return result    }    method operatorSymbol {        return "+"    }    method convertToDNF {        // if I represent ( t | u ) + (w), then we need to push the variant to the top level, and create        // (t + w) | (u + w)        def variantExpression = operands.detect { each →            each.isVariant        } ifNone {            return self        }        def newVariants = variantExpression.variants.collect { each →            gracePlusType.first (each) rest (operands.copyWithout (variantExpression)).convertToDNF        }        graceVariantType.withOperands (newVariants)    }}class graceVariantTypeFrom (typeExpr) {    inherit graceOperatorTypeFrom (typeExpr)     // I represent an operator expression containing the | operator, representing a type variant expression.    method methodDictionary {        return error (("a " ++ className ++ " can't be described by a method dictionary"))    }    method conformsTo (aType) inType (selfType) underAssumptions (assumptions) {        return variants.allSatisfy { each →            each.conformsTo (aType) inType (selfType) underAssumptions (assumptions)        }    }    method variants {        // answers a collection of my variants.  Since I'm a variant type, that's just my operands        return operands.copy    }    method operatorSymbol {        return "|"    }    method convertToDNF {        def originalOperands = operands        operands := OrderedCollection.new        originalOperands.do { each →            operands.addAll (each.variants)        }        return self    }    method isVariant {        return true    }}class graceAbstractType {    inherit Object    // I am the abstract superclass for the hierarchy of objects that describe types.    // A collabotrating class is graceType, which is a subclass of graceAbstractVariable, and thus can't be here physically.  The typeValue field of a graceType should be a reference to one of my subinstances (or another graceType?)    // If the type that I represent is defined (in a type declaration) to have type parameters, such as    // type Function[[Arg, Res]] = interface {    // apply(a:Arg) -> Res    // }    // then I record information about the parameterization.    // In the above example, the parameters are Arg and Res.  Their names are represented by the instance variable parameterNames, which is an OrderedCollection of Strings.    // Once a parameterized type has been instantiated with actual arguments, which is done by requesting the method instantiateWithArguments: aCollectionOfTypes, the instance variable arguments should hold an OrderedCollection of the same size as parameterNames.    method isUnknown { false }    method typeName is abstract    method methodNamed (aString) {        return methodNamed (aString) ifAbsent {            error (("there is no method " ++ aString ++ " in this type"))        }    }    method variants {        return [ self ]    }    method substitute (bindings) {        // a responsibility of those subclasses that are used to implement types,        // such as Signature (representing a method signature), and Interface.  It's        // also implemented by graceType (representing a named type), which is a        // subclass of graceAbstractVariable        flag "TODO: refactor so that this method can be implemented on a sub-hierarchy"        return subclassResponsibility    }    method isSelfType {        return false    }    method typeValue {        return self    }    method numberOfParameters {        return 0    }    method conformsTo (anotherObjectType) underAssumptions (assumptionsDictionary) {        if (anotherObjectType.isUnknown) then {            return true        }        if ((anotherObjectType == self )) then {            return true        }        if (assumptionsDictionary.at (self) includes (anotherObjectType)) then {            return true        }        if (methodNames.includesAll (anotherObjectType.methodNames).not) then {            return false        }        assumptionsDictionary.at (self) add (anotherObjectType)        return allSignaturesConformTo (anotherObjectType) underAssumptions (assumptionsDictionary)    }    method isVariant {        return false    }    method hasParameters {        return false    }}class graceMultiDictionary {    inherit Object    // I implement an identity dictionary where a key maps to an identity set of values.    // Keys not in the dictionary map to the empty set.    method initialize {        internalDict := IdentityDictionary.new    }    method at (aKey) includes (aValue) {        def entry = internalDict.at (aKey) ifAbsent {            return false        }        return entry.includes (aValue)    }    method at (aKey) {        return internalDict.at (aKey) ifAbsent {            IdentitySet.new        }    }    method keysAndValuesDo (a2ArgBlock) {        internalDict.keysAndValuesDo (a2ArgBlock)    }    method at (aName) add (aValue) {        // adds aValue to the set at key aName.  Returns the added value        def entry = internalDict.at (aName) ifAbsentPut {            IdentitySet.new        }        entry.add (aValue)        return aValue    }}class buildTypeFrom(aNode) {    inherit ast.baseVisitor    // I construct type objects (sub-instances of GraceAbstractType) from parse tree nodes.    // I'm not really a visitor, since I examine only a single node at a time     // (although I may use new instances of my class to construct type objects     // from sub-nodes).  But I use the acceptVisitor: -- visitXXX: to do double-dispatch,     // to get the approriate kind of type object for each kind of node.        aNode.acceptVisitor(self)    method acceptNodes (aCollection) {        def results = aCollection.collect { each →            acceptNode (each)        }        if ((results.size == 1)) then {            return results.first        }        error (("you need to implement a better way of collecting results in " ++ className))    }    method typeName {        return typeName    }    method visitSelfType (aSelfTypeNode) {        return GraceSelfType.instance    }    method visitInterfaceLiteral (anInterface) {        return GraceInterfaceType.from (anInterface) withName (typeName)    }    method typeName (aName) {        typeName := aName        return self    }    method visitRoot (aRootNode) {        return acceptNodes (aRootNode.sortedChildren)    }    method visitIdentifier (anIdentifier) {        if (anIdentifier.isAnonymous) then {            return error "annonymous identifer found in an expression"        }        anIdentifier.variable.ifNil {            return error "identifier not bound to a variable"        }        if (anIdentifier.variable.isType.not) then {            return GraceTypeError.notAType (anIdentifier)        }        return anIdentifier.variable    }    method visitType (aType) {        // there are two options for aType:        // — an identifier, perhaps with type parameters, such as Function⟦V, R⟧, and        // — a request with no arguments, perhaps with type parameters, such as collection.Enumerable⟦T⟧        def typeVar = aType.id.ifNil {            aType.receiver.attributeScope.lookup (aType.request)        } ifNotNil { id →            visitIdentifier (id)        }        return aType.typeArgList.ifNil {            typeVar        } ifNotNil { args →            typeVar.checkNumberOfTypeArguments (aType)            typeVar.instantiateWithArgs (args.typeArgs.collect { arg →                arg.acceptVisitor (self)            })        }    }    method visitUnknownType (aUnknownTypeNode) {        return GraceUnknownType.instance    }    method visitTypeExpression (aTypeExpression) {        aTypeExpression.ops.ifEmpty {            return aTypeExpression.term.acceptVisitor (self)        }        aTypeExpression.ops.overlappingPairsDo { ea, eb →            if ((ea.value == eb.value).not) then {                return GraceTypeError.mixedOperatorsIn (aTypeExpression)            }        }        def symbol = aTypeExpression.ops.first.value        if (("&" == symbol )) then {            return GraceAmpersandType.from (aTypeExpression) withName (typeName)        }        if (("+" == symbol )) then {            return GracePlusType.from (aTypeExpression) withName (typeName)        }        if (("|" == symbol )) then {            return GraceVariantType.from (aTypeExpression) withName (typeName)        }        error (("type expressions with " ++ symbol ++ " are not yet supported"))    }    method visitTypeDeclaration (aTypeDeclaration) {        // Notice that we do not visit the rhs value of the declaration, because this would lead to        // infinite regress in the (usual) case where the rhs mentions aTypeDeclaration id        return aTypeDeclaration.variable    }}
